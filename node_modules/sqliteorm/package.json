{
  "name": "sqliteorm",
  "version": "0.0.1",
  "description": "Another ORM for Node, supporting sqlite and postgres",
  "repository": {
    "type": "git",
    "url": "git@github.com:calidion/sqliteorm.git"
  },
  "keywords": [
    "node-pg",
    "sqlite",
    "orm"
  ],
  "dependencies": {
    "coffee-script": "X.X.X"
  },
  "author": {
    "name": "Chris Dickinson, Calidion"
  },
  "directories": {
    "lib": "./lib"
  },
  "license": [
    "New BSD License"
  ],
  "main": "./index",
  "readme": "SQLiteORM\n=========\n\nSQLiteORM is designed to be a database-agnostic ORM that interfaces nicely with various templating libraries\nand existing JavaScript code, with an eye towards being beautiful to read and write code for using CoffeeScript.\n\nThe API design is largely borrowed from [Django's ORM](https://docs.djangoproject.com/en/1.3/topics/db/models/); while\nnot 100% similar the general theme should be familiar to anyone who has worked with Django before. \n\nThere are currently adapters for [brianc's node-postgres](https://github.com/brianc/node-postgres) and [developmentseed's node-sqlite3](https://github.com/developmentseed/node-sqlite3).\n\nWhat Does It Look Like?\n-----------------------\n\nThe three major types of objects are `namespace`s (otherwise known as `Scope`s), `Model`s, and `QuerySet`s.\nNamespaces may contain one or more model definitions; these model definitions may refer to models from other namespaces.\nNamespaces are (currently) responsible for creation of database tables for their constituent models. The schema and metadata\nof a model may only be set within a namespace.\n\nLet's take a look at what the average `models.js` file might look like:\n\n````javascript\nvar models = require('sqliteorm').models;\n\nexports.ns = \nmodels.namespace('blog', function(ns) {\n    var Post = ns.create('Post');\n\n    Post.schema({\n        // field definitions need not be explictly called,\n        // uncalled fields will be instantiated with the default options.\n        'title':models.CharField,\n        'slug':models.CharField({regex:/^[\\w\\d\\-_]*$/g, unique:true}),\n        'pub_date':models.DateField({default:function() { return new Date(); }}),\n        'description':models.TextField\n    });\n\n    Post.meta({\n        'order_by':['-pub_date']\n    });\n\n    // models returned by `ns.create` are class constructor functions, just like in vanilla JS.\n    // all instances of that model will have anything you throw onto their `prototype` available to them.\n    Post.prototype.toString = function() {\n        return '<Post: '+this.title+'>';\n    };\n\n    var Section = ns.create('Section');\n\n    Section.schema({\n        'post':models.ForeignKey(Post),\n        'header':models.CharField({nullable:true, default:null}),\n        'subhead':models.CharField({nullable:true, default:null}),\n        'content':models.TextField,\n        'ordering':models.PositiveIntegerField\n    });\n\n    Section.meta({\n        'order_by':['ordering'],\n        'unique_together':['ordering', 'post']\n    });\n\n    var Tag = ns.create('Tag');\n\n    Tag.schema({\n        'name':models.CharField({max_length:100}),\n        'posts':models.ManyToMany(Post, {related_name:'tags'})\n    });\n\n    exports.Post = Post;\n    exports.Section = Section;\n    exports.Tag = Tag;\n});\n````\n\nIn this schema, a `Post` has many `Section`s, and `Tag`s may be associated with many `Post`s. Note that models are just plain-old function constructors,\nlike any JavaScript class. Also note that the `namespace` callback is executed immediately -- `export`ing models from within the namespace is encouraged.\nOutside of the namespace closure, the `schema` and `meta` methods will be unavailable and your models will be ready to use.\n\nQuerying Using Models\n---------------------\n\nBuilding on the previous example, let's look at how we might query the above objects.\n\n````javascript\nvar models = require('./models'),\n    Post = models.Post,\n    Section = models.Section,\n    Tag = models.Tag;\n\n// Model classes are automatically assigned a `Manager` (available under 'Model._default_manager' as well as 'Model.objects') which is responsible for starting queries, like so:\n_\n\n// query all of the posts.\nvar posts = Post.objects.all()\n\n// queries emit either 'data' or 'error', and nothing else.\n// when 'data' is emitted, the query has completed.\nposts.on('data', function(posts) {\n    posts.forEach(function() {\n        console.log('Got '+post);\n    });\n});\n\nposts.on('error', function(err) {\n    // handle your error, sir.\n});\n\n// you may also call posts as if it was a function taking a callback:\n// no casting necessary.\nposts(function(err, posts) {\n    // do something with posts.\n});\n\n// you may filter on the fields available to 'post'.\n// multiple arguments in one filter call will be 'AND'd together.\nvar other_posts = Post.objects.filter({title__contains:'something', slug:'something-else'});\n\n// filters may be chained, and excluded.\n// chained filters will be 'AND'd together as well.\n// exclude will produce NOT(arg AND arg AND arg)\nother_posts.filter({pub_date__lte:new Date()}).exclude({slug__startswith:'butts'});\n\n// you may use a filter to delete objects as well:\nother_posts.delete()\n\nother_posts(function(err) {\n    // if there's no 'err', your filter has run successfully\n});\n\n// if you only need one specific row, use 'get':\n\nPost.objects.get({title:'something'})(function(err, post) {\n    // if more than one 'Post' was returned, err will be an instance of Post.MultipleObjectsReturned.\n    // if no 'Post's were returned, err will be an instance of Post.DoesNotExist, \n\n    // otherwise post will be a single Post object.\n\n});\n\n\n// creation is pretty easy as well:\nvar my_post = Post.objects.create({\n    'title':'Introducing SQLiteORM',\n    'slug':'introducing-sqliteorm',\n    'pub_date':new Date(),\n    'description':'SQLiteORM'\n});\n\nmy_post.on('data', function(post) {\n    // our post object exists!\n});\n\n// you may also use this format:\nvar post = new Post({\n    'title':'Introducing SQLiteORM',\n    'slug':'introducing-sqliteorm',\n    'pub_date':new Date(),\n    'description':'SQLiteORM'\n});\n\npost.save().on('data', function(post) {\n    // my post!\n});\n\n// you may pass querysets to other querysets as arguments without waiting for them to return, as well:\n\nsection = Section.objects.create({\n    'content':'whoa',\n    'ordering':0,\n    'post':Post.objects.create({\n        'title':'Introducing SQLiteORM',\n        'slug':'introducing-sqliteorm',\n        'pub_date':new Date(),\n        'description':'SQLiteORM'\n    })\n});\n\n// errors from inner queries such as the above will be bubbled up through the 'section' queryset.\n\n// you may query across related tables, as well:\n\nsection.objects.filter({post__title__contains:'hats'});\n\n// or in reverse (the default reverse relation name is the name of the model with the foreign key, lowercased, plus '_set'):\nPost.objects.filter({section_set__content:'whoa'});\n\n// the above statement about being able to pass querysets applies to filtering, as well\nSection.objects.filter({post:Post.objects.get({pk:3})})\nSection.objects.filter({post__in:Post.objects.filter({title__contains:'something'})})\n\n// related filtered works with M2M relations:\nTag.objects.filter({post__title:'Yeah!'})\n\n// note that we configured the related name for Tags in the models above.\nPost.objects.filter({tags__name__contains:'bowser'})\n\n// filters may be limited and ordered:\n// \"give me three posts, ordered by title ASC, id DESC\"\nPost.objects.filter({pk:3}).order_by('title', '-id').limit(3)\n\n// \"give me 20 posts starting at 10.\"\nPost.objects.filter({pk:3}).limit(10, 20);\n\n````\n\nFilters execute as soon as the current stack is exhausted. \n\nLicense\n-------\nnew BSD\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/calidion/sqliteorm/issues"
  },
  "homepage": "https://github.com/calidion/sqliteorm",
  "_id": "sqliteorm@0.0.1",
  "dist": {
    "shasum": "f46886364e2217df31e161f986d4045c967d9242"
  },
  "_from": "sqliteorm@",
  "_resolved": "https://registry.npmjs.org/sqliteorm/-/sqliteorm-0.0.1.tgz"
}
